% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/01_nakedpipe.R, R/02_log_pipes.R,
%   R/03_debug_pipe.R, R/07_print_pipes.R, R/08_view_pipes.R
\name{\%..\%}
\alias{\%..\%}
\alias{\%.\%}
\alias{\%<.\%}
\alias{\%<..\%}
\alias{\%L.\%}
\alias{\%<L.\%}
\alias{\%D.\%}
\alias{\%P.\%}
\alias{\%<P.\%}
\alias{\%V.\%}
\alias{\%<V.\%}
\title{Naked pipe}
\usage{
x \%..\% expr

x \%.\% expr

x \%<.\% expr

x \%<..\% expr

x \%L.\% expr

x \%<L.\% expr

x \%D.\% expr

x \%P.\% expr

x \%<P.\% expr

x \%V.\% expr

x \%<V.\% expr
}
\arguments{
\item{x}{object to pipe in}

\item{expr}{call or sequence of calls wrapped inside \code{{}}}
}
\description{
Pipe into a sequence of calls, without repeating the pipe symbol.
}
\details{
This is inspired by Stefan Bache and Hadley Wickham's \emph{magrittr} pipe and
behaves consistently, though it doesn't use its code.
\itemize{
\item \verb{\%.\%} is the main pipe, called \strong{naked pipe}, by contrast to the traditional
more verbose \emph{magrittr} pipe.
\item \verb{\%<.\%} is the \strong{assignment pipe}, it works like \verb{\%.\%} but
assigns the result back to the input variable.
\item \verb{\%L.\%} is the \strong{logging pipe}, it works like \verb{\%.\%} but logs to the console the
calls and their execution times.
\item \verb{\%P.\%} is the \strong{printing pipe}, it works like \verb{\%.\%} but prints the output
of each step to the console.
\item \verb{\%V.\%} is the \strong{viewing pipe}, it works like \verb{\%.\%} but calls \code{View()} on
the output of each step.
calls and their execution times.
\item \verb{\%<L.\%}, \verb{\%<P.\%} and \verb{\%<V.\%} are assigning counterparts of the pipes described above.
\item \verb{\%D.\%} is the \strong{debugging pipe}, is used to go through the pipe step by
step, it gives the  same output as the standard \verb{\%.\%} pipe though it doesn't strictly
reproduces how the standard pipe works. See also
\code{?side_effect}.
}
}
\examples{

# Pipe into a sequence of calls using `\%.\%`
cars \%.\% {
  head(2)
  transform(time = dist/speed)
}

# it plays well with left to right assignment
cars \%.\% {
  head(2)
  transform(time = dist/speed)
} -> res
res

# Use `~~` for side effects
cars \%.\% {
  head(2)
  ~~ message("nrow:", nrow(.))
  transform(time = dist/speed)
}

# This include assignments
cars \%.\% {
  head(2)
  ~~ cars_h <- .
  transform(time = dist/speed)
}
cars_h

# Assign in place using `\%<.\%`
cars_copy <- cars
cars_copy \%<.\% {
  head(2)
  ~~ message("nrow:", nrow(.))
  transform(time = dist/speed)
}
cars_copy

# Clock each step using `\%L.\%`
cars \%L.\% {
  head(2)
  ~~ Sys.sleep(1)
  transform(time = dist/speed)
}

\dontrun{
# Debug the pipe using `\%D.\%`
cars \%D.\% {
  head(2)
  ~~ message("nrow:", nrow(.))
  transform(time = dist/speed)
}
}

# `\%..\%` is faster at the cost of using explicit dots
cars \%..\% {
  head(.,2)
  transform(.,time = dist/speed)
}

# It is better suited for programming and doesn't support side effect
# notation, but you can do :
cars \%..\% {
  head(.,2)
  {message("nrow:", nrow(.)); .}
  transform(.,time = dist/speed)
}

}
